{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the Projects Class Documentation The Projects Class is a Python class for managing projects in the WE1S Workflow Management System (WMS) and Virtual Workspace. View the code at https://github.com/whatevery1says/projectclass .","title":"Home"},{"location":"#welcome-to-the-projects-class-documentation","text":"The Projects Class is a Python class for managing projects in the WE1S Workflow Management System (WMS) and Virtual Workspace. View the code at https://github.com/whatevery1says/projectclass .","title":"Welcome to the Projects Class Documentation"},{"location":"api/","text":"Methods Note Currently, all methods are public. Danger Status Tested Methods Project.clean() Project.copy() Project.copy_templates() Project.delete() Project.exists() Project.get_latest_version_number() Project.get_latest_version() Project.get_version() Project.parse_version() Project.print_manifest() Project.unzip() Project.zip() Provisionally Tested Methods Project.export() -- has not yet been tested on pre-existing zipfiles and project folders in the Workspace Project.clean( self ) Gets a reduced version of the manifest, removing empty values Project.copy( self , name , version=None ) Inserts a copy of the current project into the database using a new name and _id . If no version is supplied, the latest version is used. Regardless, the new project is reset to version 1. If the user wishes to work with a copy of a project without saving it to the database, they should simply launch it. The unsaved project can always be saved as a new project from within the Workspace. Tip This method could be extended to run in the Workspace, where the project folder would first be zipped up and added to the version dict in the manifest. Project.copy_templates( self , templates , project_dir ) Copies the templates from the templates folder to the a project folder. Tip There needs to be a standardised way of locating the workflow. The WMS has a config value for the templates folder, and the Workspace has a path to this template. That means that the templates folder must be flat and template folder names should be of the form topic-modeling . Project.delete( self , version=None ) Deletes a project from the database using the manifest _id . If a version number (an integer) is supplied, that version's dict is removed from the manifest content, and the record is updated in the database. Project.exists( self ) Tests whether the _id listed in the project's manifests exists in the database. Project.export( self , version=None ) Downloads the latest version of a project. If a version number (an integer) is supplied, that version is downloaded instead. Project.get_latest_version(self): Gets the dict for the latest version of a project by combining Project.get_latest_version_number() with Project.get_version() . Project.get_latest_version_number( self ) Returns the highest version number in the project's manifest. Project.get_version( self , value , key='number' ) Returns the manifest dict for a specific version of the project. The versions are searched by key containing the specified value Valid keys are date , name , and number . Project.launch( self , manifest , workflow , version=None , new=True ) Launches the latest version of a project in the Workspace. If the user does not have any datapackages stored in the database, a new v1 project_dir is created. Otherwise, if the user clicks the main rocket icon, a new project_dir is created based on the latest version. If the user clicks on a specific version's rocket icon, a project_dir based on that version's datapackage is created. Where possible, a datapackage is unzipped to the Workspace. Otherwise, the data is written to the project_dir from the database. Project.make_new_project_dir( self , project_dir , templates ) A helper function for Project.launch() . Checks whether the project_dir is currently live in the Workspace. If not, a new project_dir is created. Templates are copied to it, and data is written to the caches/json folder from the database. Project.parse_version( self , s , output=None ) Splits the folder name for a project version into its component parts, date, version number, and project name. By default the method returns all three as separate values, so it must be called like date, name, number = parse_version('2019010101121212_v1_myproject') The output parameter can be set to 'date', 'name', or 'number' to return a single value: date = parse_version('2019010101121212_v1_myproject', output='date') Project.save( self , new=False ) Updates the manifest record in the database or inserts a new one with version 1 and an empty workflow in the manifest. Tip This method could be extended to run in the Workspace, where the project folder would first be zipped up and added to the version dict in the manifest. Setting new=True would commit the zip file to a new version number within the existing project. Project.unzip( self , filepath=None , output_path=None ) Unzips the specified file to a specified folder. Project.zip( self , filename , source_dir , destination_dir ) Creates a zip archive of the source_dir and writes it to the destination_dir . The method is generally called by Project.export() with the project_dir and exports_dir as parameters.","title":"Project Class API"},{"location":"api/#methods","text":"Note Currently, all methods are public. Danger","title":"Methods"},{"location":"api/#status","text":"","title":"Status"},{"location":"api/#tested-methods","text":"Project.clean() Project.copy() Project.copy_templates() Project.delete() Project.exists() Project.get_latest_version_number() Project.get_latest_version() Project.get_version() Project.parse_version() Project.print_manifest() Project.unzip() Project.zip()","title":"Tested Methods"},{"location":"api/#provisionally-tested-methods","text":"Project.export() -- has not yet been tested on pre-existing zipfiles and project folders in the Workspace","title":"Provisionally Tested Methods"},{"location":"api/#projectcleanself","text":"Gets a reduced version of the manifest, removing empty values","title":"Project.clean(self)"},{"location":"api/#projectcopyself-name-versionnone","text":"Inserts a copy of the current project into the database using a new name and _id . If no version is supplied, the latest version is used. Regardless, the new project is reset to version 1. If the user wishes to work with a copy of a project without saving it to the database, they should simply launch it. The unsaved project can always be saved as a new project from within the Workspace. Tip This method could be extended to run in the Workspace, where the project folder would first be zipped up and added to the version dict in the manifest.","title":"Project.copy(self, name, version=None)"},{"location":"api/#projectcopy_templatesself-templates-project95dir","text":"Copies the templates from the templates folder to the a project folder. Tip There needs to be a standardised way of locating the workflow. The WMS has a config value for the templates folder, and the Workspace has a path to this template. That means that the templates folder must be flat and template folder names should be of the form topic-modeling .","title":"Project.copy_templates(self, templates, project_dir)"},{"location":"api/#projectdeleteself-versionnone","text":"Deletes a project from the database using the manifest _id . If a version number (an integer) is supplied, that version's dict is removed from the manifest content, and the record is updated in the database.","title":"Project.delete(self, version=None)"},{"location":"api/#projectexistsself","text":"Tests whether the _id listed in the project's manifests exists in the database.","title":"Project.exists(self)"},{"location":"api/#projectexportself-versionnone","text":"Downloads the latest version of a project. If a version number (an integer) is supplied, that version is downloaded instead.","title":"Project.export(self, version=None)"},{"location":"api/#projectget_latest_versionself","text":"Gets the dict for the latest version of a project by combining Project.get_latest_version_number() with Project.get_version() .","title":"Project.get_latest_version(self):"},{"location":"api/#projectget_latest_version_numberself","text":"Returns the highest version number in the project's manifest.","title":"Project.get_latest_version_number(self)"},{"location":"api/#projectget_versionself-value-keynumber","text":"Returns the manifest dict for a specific version of the project. The versions are searched by key containing the specified value Valid keys are date , name , and number .","title":"Project.get_version(self, value, key='number')"},{"location":"api/#projectlaunchself-manifest-workflow-versionnone-newtrue","text":"Launches the latest version of a project in the Workspace. If the user does not have any datapackages stored in the database, a new v1 project_dir is created. Otherwise, if the user clicks the main rocket icon, a new project_dir is created based on the latest version. If the user clicks on a specific version's rocket icon, a project_dir based on that version's datapackage is created. Where possible, a datapackage is unzipped to the Workspace. Otherwise, the data is written to the project_dir from the database.","title":"Project.launch(self, manifest, workflow, version=None, new=True)"},{"location":"api/#projectmake_new_project_dirself-project95dir-templates","text":"A helper function for Project.launch() . Checks whether the project_dir is currently live in the Workspace. If not, a new project_dir is created. Templates are copied to it, and data is written to the caches/json folder from the database.","title":"Project.make_new_project_dir(self, project_dir, templates)"},{"location":"api/#projectparse_versionself-s-outputnone","text":"Splits the folder name for a project version into its component parts, date, version number, and project name. By default the method returns all three as separate values, so it must be called like date, name, number = parse_version('2019010101121212_v1_myproject') The output parameter can be set to 'date', 'name', or 'number' to return a single value: date = parse_version('2019010101121212_v1_myproject', output='date')","title":"Project.parse_version(self, s, output=None)"},{"location":"api/#projectsaveself-newfalse","text":"Updates the manifest record in the database or inserts a new one with version 1 and an empty workflow in the manifest. Tip This method could be extended to run in the Workspace, where the project folder would first be zipped up and added to the version dict in the manifest. Setting new=True would commit the zip file to a new version number within the existing project.","title":"Project.save(self, new=False)"},{"location":"api/#projectunzipself-filepathnone-output95pathnone","text":"Unzips the specified file to a specified folder.","title":"Project.unzip(self, filepath=None, output_path=None)"},{"location":"api/#projectzipself-filename-source95dir-destination95dir","text":"Creates a zip archive of the source_dir and writes it to the destination_dir . The method is generally called by Project.export() with the project_dir and exports_dir as parameters.","title":"Project.zip(self, filename, source_dir, destination_dir)"},{"location":"creating/","text":"Creating and Using Projects A project object must have a pre-existing manifest. If the project is new, the manifest must be created before the project object is instantiated. The WMS serialises the form data in the user interface to create a new manifest. In the Workspace, the manifest would have to be done programmatically, but, in general, the Workspace will already have a manifest in an existing project folder. Once a manifest is associated the project, the project object can be instantiated using project_name = Project(manifest, templates_dir, workspace_dir) Thereafter, project methods can be called with code like project_name.save() .","title":"Creating and Using Projects"},{"location":"creating/#creating-and-using-projects","text":"A project object must have a pre-existing manifest. If the project is new, the manifest must be created before the project object is instantiated. The WMS serialises the form data in the user interface to create a new manifest. In the Workspace, the manifest would have to be done programmatically, but, in general, the Workspace will already have a manifest in an existing project folder. Once a manifest is associated the project, the project object can be instantiated using project_name = Project(manifest, templates_dir, workspace_dir) Thereafter, project methods can be called with code like project_name.save() .","title":"Creating and Using Projects"},{"location":"importing/","text":"Importing the Projects class as a module The final form of this is yet to be determined. In the WMS, it will be something like from app.projects import Project In the Workspace, it may be something like import sys project_module_path = 'templates/modules/Project' if project_module_path not in sys.path: sys.path.append(project_module_path) import function project_module_path","title":"Importing"},{"location":"importing/#importing-the-projects-class-as-a-module","text":"The final form of this is yet to be determined. In the WMS, it will be something like from app.projects import Project In the Workspace, it may be something like import sys project_module_path = 'templates/modules/Project' if project_module_path not in sys.path: sys.path.append(project_module_path) import function project_module_path","title":"Importing the Projects class as a module"},{"location":"versioning/","text":"Project Versioning The Project class implements a light versioning system by storing version metadata in the manifest's content property. Projects versions are maintained as a list of dicts. Each dict has the following properties: version_date : A timestamp string with the format %Y%m%d%H%M%S . version_number : An integer. version_name : A string consisting of the timestamp, version number, and manifest name . See below for the method construction. version_workflow : A string with the name of folder containing the templates used by the project version. The format must be lower case alphanumeric characters with words separated by - . If there is no workflow, it may be None (translating to Null in JSON). See below naming workflow versions. version_zipfile : A binary zip archive containing a datapackage of the project version. The version_name is formed by concatenating the version_date , the version_number , and the manifest name , separated by _ . The version_number should be preceded by v . An example is 20190131122714_v1_nyt_humanities . A typical version dict would look like this: { 'version_date': '20190131122714', 'version_name': '20190131122714_v1_nyt_humanities', 'version_number': 2, 'version_workflow': 'topic-modeling', 'version_zipfile': <datapackage> } Since templates may be revised, it is recommended that template folder names also indicate version numbers like topic-modeling_v2 .","title":"Project Versioning"},{"location":"versioning/#project-versioning","text":"The Project class implements a light versioning system by storing version metadata in the manifest's content property. Projects versions are maintained as a list of dicts. Each dict has the following properties: version_date : A timestamp string with the format %Y%m%d%H%M%S . version_number : An integer. version_name : A string consisting of the timestamp, version number, and manifest name . See below for the method construction. version_workflow : A string with the name of folder containing the templates used by the project version. The format must be lower case alphanumeric characters with words separated by - . If there is no workflow, it may be None (translating to Null in JSON). See below naming workflow versions. version_zipfile : A binary zip archive containing a datapackage of the project version. The version_name is formed by concatenating the version_date , the version_number , and the manifest name , separated by _ . The version_number should be preceded by v . An example is 20190131122714_v1_nyt_humanities . A typical version dict would look like this: { 'version_date': '20190131122714', 'version_name': '20190131122714_v1_nyt_humanities', 'version_number': 2, 'version_workflow': 'topic-modeling', 'version_zipfile': <datapackage> } Since templates may be revised, it is recommended that template folder names also indicate version numbers like topic-modeling_v2 .","title":"Project Versioning"}]}